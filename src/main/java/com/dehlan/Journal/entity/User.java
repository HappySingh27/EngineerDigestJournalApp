package com.dehlan.Journal.entity;


// POJO Class

import lombok.*;
import org.bson.types.ObjectId;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.DBRef;
import org.springframework.data.mongodb.core.mapping.Document;
import java.util.ArrayList;
import java.util.List;

/*
*  @Document - will tell SpringBoot that this class is mapped with MongoDB collection
*  Entity - User - will give login functionality using this user class
*  Every user will have multiple entities (JournalEntry in our case)
*  JournalEntry will be associated to particular User,
*  Each User will have their own entities (JournalEntry)
*  We will implement basic User authentication using this.
*
*/

/*
***Generated by AI, may contain errors***
 * ✅ Important: Model/Entity classes should NOT be Spring Beans
 *
 * - @Document maps this class to a MongoDB collection for persistence,
 *   but does NOT register it with the Spring IoC container.
 * - Spring Beans are registered via @Component, @Service, @Repository,
 *   or @Bean definitions. Only these are managed and injectable by Spring.
 *
 * ⚠️ Why not make models beans?
 * - Entities represent **per-instance data**, not shared services or components.
 * - Autowiring them (e.g., @Autowired private User user;) fails since they
 *   are not managed by Spring and leads to runtime errors :contentReference[officiate:1]{index=1}.
 * - Mixing persistence entities with Spring context breaks **separation of concerns**, can cause tight coupling, and makes testing harder :contentReference[oaicite:2]{index=2}.
 *
 * ✅ Best practice:
 * - Use Services (@Service) and Repositories (@Repository/MongoRepository) as beans.
 * - Keep entity classes simple, used only for data mapping.
 ---------------------------------------------------------------------------------------
 * ⚠️ Important Notes: Why Entity classes should NOT be annotated with @Component or made Spring Beans
 *
 * 1️⃣ If you annotate an @Entity class (like User, Product, etc.) with @Component:
 *     ➤ Spring will treat it as a singleton bean — meaning only one shared instance is created and reused.
 *     ➤ But this is bad for entity classes, which are meant to hold request-specific or user-specific data.
 *
 * 2️⃣ Entity objects represent dynamic data that often:
 *     ➤ Changes with each request (e.g., a new user registering or updating info)
 *     ➤ Needs to be persisted to or fetched from the database
 *     ➤ Should have a fresh instance per request or per transaction
 *
 * 3️⃣ On the other hand, @Component or @Service classes (like WeatherService, UserService):
 *     ➤ Contain business logic (rules, formulas, reusable logic)
 *     ➤ Do NOT change per request — same logic is used again and again
 *     ➤ Are perfect as Spring-managed singletons
 *
 * 4️⃣ So, in simple terms:
 *     ✅ Services = Formulas (fixed logic, same for all)
 *     ✅ Entities = Data passed into those formulas (varies with each request)
 *
 * 5️⃣ Making entities Spring Beans leads to:
 *     ❌ Thread-safety issues
 *     ❌ Wrong or shared data across users
 *     ❌ Confusing object lifecycle (Spring vs JPA)
 *
 * ✅ Conclusion: Keep @Entity classes pure — no @Component/@Service on them.
 * Let Spring manage services, and JPA/Hibernate manage entity instances.
 */

@Document(collection = "user") // will tell SpringBoot that this class is mapped with MongoDB collection ("User"))
@Data // equivalent to @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor
@NoArgsConstructor
@AllArgsConstructor // this is needed for @Builder, - it needs all args constructor

/*
 * @Builder (Lombok)
 * -----------------
 * Lombok's @Builder annotation implements the Builder design pattern.
 * It auto-generates:
 *   - A static builder() method
 *   - A nested builder class with setter-like methods
 *   - A build() method to construct the object
 */

/*
 * Problem Without Builder
 * ------------------------
 * Imagine a class with 100 fields.
 * Without Builder pattern, you'd need:
 *   - 100 overloaded constructors (1-arg, 2-arg, ..., 100-arg)
 *   - Or one long constructor with 100 parameters (very hard to read, use, or maintain)
 *
 * Example:
 * new Employee("John", null, null, ..., 100 args)  ❌ Very confusing and error-prone
 *
 * ✅ Solution: Use Builder Pattern
 * -------------------------------
 * With @Builder, you only set the fields you need using a fluent, readable style:
 *
 * Example:
 * Employee emp = Employee.builder()
 *                        .name("John")
 *                        .department("IT")
 *                        .salary(50000)
 *                        // set only what you need
 *                        .build();
 *
 * ✅ Benefits:
 * - No need to write or maintain 100 constructors
 * - Code is clean and readable
 * - Reduces bugs from wrong argument order
 * - Supports immutability
 */
@Builder
public class User {

    @Id  // to make unique key in MongoDb
    private ObjectId id;

    /*
     * need to update property in application.yml file,
     * spring.data.mongodb.auto-index-creation=true, otherwise
     * @Indexed would not work
     *
     * Annotations like @Component, @Service, @RestController are purely Spring-level concepts and
     * are handled internally via component scanning — no extra config needed.
     * But @Indexed performs an external DB operation, so Spring requires explicit permission (via properties),
     * to avoid risky automatic schema changes — especially in production.
     *
     * */
    @Indexed(unique = true)
    @NonNull
    private String userName;
    @NonNull
    private String password;
    private String email;
    private boolean sentimentAnalysis;
    private List<String> roles;

    /*
    * @DBRef is used in a model class to tell Spring Data MongoDB:
    * “This field is a reference to another document in another MongoDB collection.”
    *  This is like a Foreign key
    * */
    @DBRef
    private List<JournalEntry> journalEntries = new ArrayList<>();

}
